## 浏览器工作原理

1. 浏览器是多个进程模块互相配合工作，进程之间通过**进程间通信IPC**来进行通信。
2. 以Chrome为例，所含进程如下：
   - Browser Process：顶层进程，负责网络请求，文件访问，书签栏，前进后退等，并协调其他各个进程
     - UI线程
     - 网络线程
     - 存储线程
   - Renderer Process：渲染进程，负责页面渲染
     - 主线程
     - 工作线程
     - 排版线程
     - 光栅线程
   - GPU进程
   - 插件进程

3. 输入URL之后，UI线程判断是url还是query，然后通知网络线程去获取网页内容，并控制tab的旋转标签进行旋转。

4. 网络线程会执行DNS查询请求，DNS请求通过UDP报文传输；随后通过套接字建立TCP的三次握手；如果收到的响应码是301，网络进程会通知UI线程进行重定向。

5. 收到响应时，网络线程会根据content-type判断格式，如果是html会先通知UI线程，UI线程会通知渲染进程进行渲染。**加速方案**就是，发送URL时，UI线程立即查找并启动渲染进程。

6. 浏览器进程会通知渲染进程进行渲染，这个过程tab的圈圈一直在转。渲染结束后渲染进程通知UI线程停止转圈。

7. 渲染详细流程

   - 构建DOM：主线程将html字符串解析为DOM

   - 加载次级资源：此时网络线程也会对一些资源如img、link进行加载

   - 碰到<script>标签时，停止解析，而是去加载解析和执行js代码，停止解析html是因为js可能会改变dom的结构；async允许异步执行js代码，下载后立即执行；defer是推迟，应用情形是一个脚本依赖于另外一个脚本，整个文档解析完毕后才会执行js。

   - 主线程基于CSS选择器解析CSS获取每一个节点的最终样式值，兜底为默认样式。

   - 获取几何位置关系，主线程构建出每个元素的坐标信息和盒子大小，如果是display: none就不会在不拘束上

   - 构建绘制各元素的顺序，主线程会遍历布局树，按照遍历顺序进行绘制，并记录绘制顺序。

   - 合成帧：主线程遍历布局树创建层树（layer tree），此时层树和绘制顺序都已经确定，主线程通知排版线程，排版线程会栅格化每一层，具体地，排版线程会把各个层分成多个块，叫磁贴，然后由光山进城进行栅格化并存储在GPU显存中。之后，排版线程收集这些被光栅化的磁贴并创建合成帧，这些合成帧发送给GPU并显示在屏幕上。

     

     